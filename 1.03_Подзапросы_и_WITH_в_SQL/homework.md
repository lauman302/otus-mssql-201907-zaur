# Подзапросы и CTE

Для всех заданий где возможно, сделайте 2 варианта запросов:

1. через вложенный запрос
2. через WITH (для производных таблиц)

Напишите запросы:

1. Выберите сотрудников, которые являются продажниками, и еще не сделали
ни одной продажи.

    ```
    1.03.01.sql
    ```

2. Выберите товары с минимальной ценой (подзапросом), 2 варианта подзапроса.

    ```
    1.03.02.sql
    ```

3. Выберите информацию по клиентам, которые перевели компании 5 максимальных
платежей из `[Sales].[CustomerTransactions]` представьте 3 способа (в том числе
с CTE)

    ```
    1.03.03.sql
    ```

4. Выберите города (ид и название), в которые были доставлены товары, входящие
в тройку самых дорогих товаров, а также Имя сотрудника, который осуществлял
упаковку заказов.

    ```
    1.03.04.sql
    ```

5. Объясните, что делает и оптимизируйте запрос:

    ```sql
    SELECT
        Invoices.InvoiceID,
        Invoices.InvoiceDate,
        (
            SELECT People.FullName
            FROM Application.People
            WHERE People.PersonID = Invoices.SalespersonPersonID
        ) AS SalesPersonName,
        SalesTotals.TotalSumm AS TotalSummByInvoice,
        (
            SELECT SUM(OrderLines.PickedQuantity*OrderLines.UnitPrice)
            FROM Sales.OrderLines
            WHERE OrderLines.OrderId = (
                SELECT Orders.OrderId
                FROM Sales.Orders
                WHERE Orders.PickingCompletedWhen IS NOT NULL
                AND Orders.OrderId = Invoices.OrderId
            )
        ) AS TotalSummForPickedItems
    FROM
        Sales.Invoices
        JOIN (
            SELECT InvoiceId, SUM(Quantity*UnitPrice) AS TotalSumm
            FROM Sales.InvoiceLines
            GROUP BY InvoiceId
            HAVING SUM(Quantity*UnitPrice) > 27000
        ) AS SalesTotals
        ON Invoices.InvoiceID = SalesTotals.InvoiceID
    ORDER BY TotalSumm DESC
    ```

    Приложите план запроса и его анализ, а также ход ваших рассуждений по поводу
    оптимизации.

    Можно двигаться как в сторону улучшения читабельности запроса (что уже было
    в материале лекций), так и в сторону упрощения плана\ускорения.

    ----

    Запрос выбирает список счетов-фактур (Invoice) с общей суммой всех товаров в них более 27000, общей суммой произведённых по этим с/ф отгрузок и именем продавца.

    План запроса до оптимизации ([xml][xml_before]):
    ![План запроса до оптимизации][plan_before]

    В исходном запросе есть зависимые подзапросы в SELECT (один из которых является вложенным). Также на плане видно множество параллельных операций. Для оптимизации, вынесем рассчёт аггрегированных значений (сумм с/ф и сумм отгрузок) в CTE: это улучшит читаемость запроса и избавит от повторного выполнения подзапросов. Оптимизированный запрос:

    ```
    1.03.04.sql
    ```

    План запроса после оптимизации ([xml][xml_after]):
    ![План запроса после оптимизации][plan_after]

Опциональная часть:

6. В материалах к вебинару есть файл `HT_reviewBigCTE.sql` - прочтите этот запрос
и напишите что он должен вернуть и в чем его смысл, можно если есть идеи
по улучшению тоже их включить.

    ----

    В приведённом файле только часть запроса, которая формирует два CTE. Судя по названиям, эти CTE должны использоваться для дальнейшего удаления записей о пользовательских файлах. При этом, CTE `cteDeletedDF` выбирает файлы, превысившие заданный срок хранения, а CTE `cteDeletedDFMatchedRules` выбирает из `cteDeletedDF` файлы по срабатыванию неких правил, заданных во временной таблице `#companyCustomRules`.

    В скрипте присутствуют переменные, однако они не были ни объявлены, ни инициализированы. Возможно, скрипт является частью ХП, куда они передаются как параметры. По логике скрипта, можно сделать такие предположения о их назначении:

    * @DFBatchSize -- количество файлов, обрабатываемых за один проход;
    * @vfId -- ID виртуальной паки;
    * @vfOwnerId -- ID  владельца виртуальной папки;
    * @vfFolderId -- ID папки (чем отличается от виртуальной папки непонятно),
    * @maxDFKeepDate -- максмальная дата хранения файла (?) в UTC,
    * @keepDeletedFromDate -- дата для расчёта даты удаления файла по таблице нестандартных условий (?).

    Судя по условиям отбора, используются такие правила:

    * прямое указание ID файла. В зависимости от `RuleCondition` он либо принудительно включается в список, либо принудительно исключается;
    * задание конкретного файла;
    * задание маски файла (вхождения). В зависимости от `RuleCondition` поле `RuleItemFileMask` будет стоять в произвольном месте, в начале, в конце имени или будет regexp'ом;
    * задание размера файла. В зависимости от `RuleCondition`, будут отобраны файлы больше или меньше поля `RuleItemFileSize`;
    * прямое указание ID виртуальной папки;
    * прямое указание ID владельца виртуальной папки.

    Идеи по улучшению пока простейшие:
    * указать алиасы везде одинаково (сейчас есть, например, df и DF);
    * предполагаю, что `TOP 1` внутри `EXISTS` не нужен.

Рекомендуем сдать до: 14.08.2019

[plan_before]: images/1.03.5_plan_before.png
[plan_after]: images/1.03.5_plan_after.png
[xml_before]: ./1.03.5_plan_before.xml
[xml_after]: ./1.03.5_plan_after.xml
